package self

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	yaml "gopkg.in/yaml.v3"

	"github.com/bookandmusic/dev-tools/internal/config"
	"github.com/bookandmusic/dev-tools/internal/manager/soft"
	"github.com/bookandmusic/dev-tools/internal/ui"
	"github.com/bookandmusic/dev-tools/internal/utils"
)

type SelfManager struct{}

func (s *SelfManager) Install(ctx context.Context) error {
	params, err := soft.Parse[BaseParams](ctx)
	if err != nil {
		return err
	}
	cfg := params.Cfg
	ui := params.UI
	rootAbsDir := utils.ExpandAbsDir(cfg.Common.RootDir)

	pluginDir := filepath.Join(rootAbsDir, "plugins")
	binDir := filepath.Join(rootAbsDir, "bin")

	ui.Info("Installing dev-tools to: %s", rootAbsDir)

	// 1️⃣ 创建安装目录
	if err := s.createInstallDirs(binDir, pluginDir); err != nil {
		return err
	}

	// 2️⃣ 复制当前可执行文件到 bin
	if err := s.copyExecutable(binDir, ui); err != nil {
		return err
	}

	// 3️⃣ 复制 plugins（如果有）
	if err := s.copyPlugins(cfg.Common.WorkDir, pluginDir, ui); err != nil {
		return err
	}

	// 4️⃣ 生成默认配置
	if err := s.generateConfig(rootAbsDir, cfg); err != nil {
		return err
	}

	// 5️⃣ 生成 .env
	if err := s.generateEnvFile(rootAbsDir, binDir, ui); err != nil {
		return err
	}

	// 6️⃣ 生成加载脚本 load_dtl.sh
	loadScriptPath, err := s.generateLoadScript(rootAbsDir, ui)
	if err != nil {
		return err
	}

	// 7️⃣ 链接到用户 shell 配置文件
	if err := s.linkToShellProfile(loadScriptPath, ui); err != nil {
		return err
	}

	ui.Success("Installation complete. Run `source %s` or restart shell to apply.", loadScriptPath)
	return nil
}

func (s *SelfManager) createInstallDirs(binDir, pluginDir string) error {
	if err := os.MkdirAll(binDir, 0o700); err != nil {
		return fmt.Errorf("failed to create bin dir: %w", err)
	}
	if err := os.MkdirAll(pluginDir, 0o700); err != nil {
		return fmt.Errorf("failed to create plugins dir: %w", err)
	}
	return nil
}

func (s *SelfManager) copyExecutable(binDir string, ui ui.UI) error {
	execPath, err := os.Executable()
	if err != nil {
		return fmt.Errorf("failed to get exec path: %w", err)
	}
	targetPath := filepath.Join(binDir, "dtl")
	if err := utils.CopyFile(execPath, targetPath); err != nil {
		return fmt.Errorf("failed to copy exec: %w", err)
	}
	ui.Info("Copied executable to: %s", targetPath)
	return nil
}

func (s *SelfManager) copyPlugins(workDir, pluginDir string, ui ui.UI) error {
	if workDir == "" || !utils.PathExists(workDir) {
		execPath, _ := os.Executable()
		workDir = filepath.Dir(execPath)
	}
	srcPlugins := filepath.Join(workDir, "plugins")
	if info, err := os.Stat(srcPlugins); err == nil && info.IsDir() {
		if err := utils.CopyDirWithProgress(srcPlugins, pluginDir, ui); err != nil {
			return fmt.Errorf("failed to copy plugins: %w", err)
		}
	} else {
		ui.Warning("No plugins directory found")
	}
	return nil
}

func (s *SelfManager) generateConfig(rootAbsDir string, cfg *config.GlobalConfig) error {
	cfg.Common.WorkDir = cfg.Common.RootDir
	configFile := filepath.Join(rootAbsDir, "config.yml")
	if _, err := os.Stat(configFile); os.IsNotExist(err) {
		data, _ := yaml.Marshal(cfg)
		if err := os.WriteFile(configFile, data, 0o600); err != nil {
			return fmt.Errorf("failed to create config file: %w", err)
		}
	}
	return nil
}

func (s *SelfManager) generateEnvFile(rootAbsDir, binDir string, ui ui.UI) error {
	envFile := filepath.Join(rootAbsDir, ".env")
	err := utils.UpdateEnvFile(envFile, map[string]string{
		"PATH":           binDir,
		"DEV_TOOLS_HOME": rootAbsDir,
	}, "add")
	if err != nil {
		ui.Error("添加环境变量失败")
		return err
	}
	ui.Info("Generated .env file: %s", envFile)
	return nil
}

func (s *SelfManager) generateLoadScript(rootAbsDir string, ui ui.UI) (string, error) {
	envFile := filepath.Join(rootAbsDir, ".env")
	loadScriptPath := filepath.Join(rootAbsDir, "load_dtl.sh")
	loadScript := fmt.Sprintf(`#!/bin/sh
# Auto-generated by dev-tools installer
ENV_FILE="%s"
if [ -f "$ENV_FILE" ]; then
    set -a
    . "$ENV_FILE"
    set +a
fi
`, envFile)
	if err := os.WriteFile(loadScriptPath, []byte(loadScript), 0o600); err != nil {
		return "", fmt.Errorf("failed to write loader: %w", err)
	}

	if err := os.Chmod(loadScriptPath, 0o700); err != nil {
		return "", fmt.Errorf("failed to chmod loader: %w", err)
	}
	ui.Info("Generated load script: %s", loadScriptPath)
	return loadScriptPath, nil
}

func (s *SelfManager) linkToShellProfile(loadScriptPath string, ui ui.UI) error {
	currentUser, _ := utils.GetCurrentUser()
	homeDir, shell, _ := utils.GetUserHomeAndShell(currentUser.Username)
	profilePath := utils.GetProfilePath(shell, homeDir)

	// 写入用户 profile
	block := fmt.Sprintf(`# >>> dev-tools >>>
[ -s "%s" ] && . "%s"
# <<< dev-tools <<<`, loadScriptPath, loadScriptPath)

	if err := utils.EnsureBlockInFile(profilePath, "# >>> dev-tools >>>", "# <<< dev-tools <<<", block); err != nil {
		return fmt.Errorf("failed to update %s: %w", profilePath, err)
	}
	ui.Info("Linked loader into: %s", profilePath)
	return nil
}

func (s *SelfManager) Uninstall(ctx context.Context) error {
	params, err := soft.Parse[BaseParams](ctx)
	if err != nil {
		return err
	}
	ui := params.UI
	cfg := params.Cfg
	rootAbsDir := utils.ExpandAbsDir(cfg.Common.RootDir)

	ui.Info("Uninstalling dev-tools from: %s", rootAbsDir)

	// 删除安装目录
	if utils.PathExists(rootAbsDir) {
		if err := os.RemoveAll(rootAbsDir); err != nil {
			return fmt.Errorf("failed to remove %s: %w", rootAbsDir, err)
		}
		ui.Info("Removed: %s", rootAbsDir)
	}

	// 删除 shell 配置文件里的加载入口
	currentUser, _ := utils.GetCurrentUser()
	homeDir, shell, _ := utils.GetUserHomeAndShell(currentUser.Username)
	profilePath := utils.GetProfilePath(shell, homeDir)
	// 从 profile 移除 block
	if err := utils.RemoveLinesInFile(profilePath, "# >>> dev-tools >>>", "# <<< dev-tools <<<"); err != nil {
		ui.Warning("Failed to clean profile: %s", err)
	} else {
		ui.Info("Cleaned dev-tools environment block from: %s", profilePath)
	}

	ui.Success("Uninstall complete.")
	return nil
}

func (s *SelfManager) Update(ctx context.Context) error {
	params, err := soft.Parse[BaseParams](ctx)
	if err != nil {
		return err
	}
	ui := params.UI

	// Update = Uninstall + Install
	ui.Info("Updating dev-tools...")
	if err := s.Uninstall(ctx); err != nil {
		return fmt.Errorf("failed to uninstall during update: %w", err)
	}
	if err := s.Install(ctx); err != nil {
		return fmt.Errorf("failed to install during update: %w", err)
	}
	ui.Success("Update complete.")
	return nil
}

func init() {
	soft.Register("self", &SelfManager{})
}
